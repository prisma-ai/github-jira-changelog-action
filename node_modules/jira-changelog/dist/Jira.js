"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("@babel/polyfill");

var _jiraClient = _interopRequireDefault(require("jira-client"));

var _promiseThrottle = _interopRequireDefault(require("promise-throttle"));

var _Slack = _interopRequireDefault(require("./Slack"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const promiseThrottle = new _promiseThrottle.default({
  requestsPerSecond: 10,
  promiseImplementation: Promise
});
/**
 * Generate changelog by matching source control commit logs to jiar tickets.
 */

class Jira {
  constructor(config) {
    this.config = config;
    this.slack = new _Slack.default(config);
    this.jira = undefined;
    this.releaseVersions = [];
    this.ticketPromises = {};
    const {
      host,
      username,
      password
    } = config.jira.api;
    let {
      email,
      token
    } = config.jira.api;

    if (!token && typeof password !== 'undefined') {
      console.warn('WARNING: Jira password is deprecated. Use an API token instead.');
      token = password;
    }

    if (!email && typeof username !== 'undefined') {
      console.warn('WARNING: Jira username is deprecated for API authentication. Use user email instead.');
      email = username;
    }

    if (config.jira.api.host) {
      this.jira = new _jiraClient.default({
        host,
        username: email,
        password: token,
        protocol: 'https',
        apiVersion: 2,
        strictSSL: true
      });
    }
  }
  /**
   * Generate changelog by matching source control commit logs to jira tickets
   * and, optionally, creating the release version.
   *
   * @param {Array} commitLogs - A list of source control commit logs.
   * @param {String} releaseVersion - The name of the release version to create.
   * @return {Object}
   */


  generate(commitLogs, releaseVersion) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const logs = [];
      _this.releaseVersions = [];

      try {
        const promises = commitLogs.map(commit => {
          return _this.findJiraInCommit(commit, releaseVersion).then(log => {
            logs.push(log);
          });
        });
        promises.push(Promise.resolve()); // ensure at least one

        return Promise.all(promises) // Add to release version
        .then(() => {
          // Get all Jira tickets (filter out duplicates by keying on ID)
          let ticketsHash = {};
          let ticketsList = [];
          logs.forEach(log => {
            log.tickets.forEach(ticket => ticketsHash[ticket.id] = ticket);
          });
          ticketsList = Object.keys(ticketsHash).map(k => ticketsHash[k]); // If there are Jira tickets, create a release for them

          if (ticketsList.length && releaseVersion) {
            return _this.addTicketsToReleaseVersion(ticketsList, releaseVersion).then(() => logs);
          }

          return logs;
        });
      } catch (e) {
        throw new Error(e);
      }
    })();
  }
  /**
   * Find JIRA ticket numbers in a commit log, and automatically load the
   * ticket info for it.
   *
   * @param {Object} commitLog - Commit log object
   * @param {String} releaseVersion - Release version eg, mobileweb-1.8.0
   * @return {Promsie} Resolves to an object with a jira array property
   */


  findJiraInCommit(commitLog) {
    const log = Object.assign({
      tickets: []
    }, commitLog);
    const promises = [];
    const found = {};
    const configPattern = this.config.jira.ticketIDPattern;
    const ticketPattern = new RegExp(configPattern.source, configPattern.flags.replace('g', '')); // Search for jira ticket numbers in the commit text

    const tickets = this.getTickets(log);
    tickets.forEach(ticketMatch => {
      // Get the ticket key, and skip loading if we already got this one
      let key = ticketMatch.match(ticketPattern);
      key = key.length > 1 ? key[1] : key[0];

      if (!key) {
        return;
      }

      key = key.toUpperCase();

      if (found[key]) {
        return;
      }

      found[key] = true;
      promises.push(this.getJiraTicketForCommit(log, key).catch(() => {}) // ignore errors
      );
    }); // Resolve log when all jira promises are done

    return Promise.all(promises).then(() => log);
  }
  /**
   * Load a Jira issue ticket for a commit object
   *
   * @param {Object} commitLog - Commit log object
   * @param {String} ticketKey - The Jira ticket ID key
   *
   * @return {Promise}
   */


  getJiraTicketForCommit(commitLog, ticketKey) {
    if (!ticketKey) {
      return Promise.resolve();
    } // Get Jira issue ticket object


    let promise = this.ticketPromises[ticketKey];

    if (!promise) {
      promise = promiseThrottle.add(this.getJiraIssue.bind(this, ticketKey));
      promise.catch(() => {
        console.log(`Ticket ${ticketKey} not found`);
      });
      this.ticketPromises[ticketKey] = promise;
    } // Add to commit


    promise.then(ticket => {
      if (this.includeTicket(ticket)) {
        commitLog.tickets.push(ticket);
        return ticket;
      }
    });
    return promise;
  }
  /**
   * Creates a release version and assigns tickets to it.
   *
   * @param {Array} ticket - List of Jira ticket objects
   * @param {String} versionName - The name of the release version to add the ticket to.
   * @return {Promise}
   */


  addTicketsToReleaseVersion(tickets, versionName) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const versionPromises = {};
      _this2.releaseVersions = []; // Create version and add it to a ticket

      function updateTicketVersion(ticket) {
        const project = ticket.fields.project.key; // Create version on project

        let verPromise;

        if (versionPromises[project]) {
          verPromise = versionPromises[project];
        } else {
          verPromise = this.createProjectVersion(versionName, project);
          versionPromises[project] = verPromise; // Add to list of releases

          verPromise.then(ver => {
            ver.projectKey = project;
            this.releaseVersions.push(ver);
          });
        } // Add version to ticket


        return verPromise.then(versionObj => {
          const {
            fixVersions
          } = ticket.fields;
          fixVersions.push({
            name: versionObj.name
          });
          return this.jira.updateIssue(ticket.id, {
            fields: {
              fixVersions
            }
          });
        });
      } // Loop through tickets and throttle the promises.


      const promises = tickets.map(ticket => {
        return promiseThrottle.add(updateTicketVersion.bind(_this2, ticket)).catch(err => {
          console.log(JSON.stringify(err, null, '  '));
          console.log(`Could not assign ticket ${ticket.key} to release '${versionName}'!`);
        });
      });
      return Promise.all(promises);
    })();
  }
  /**
   * Add a version to a single project, if it doesn't current exist
   * @param {String} versionName - The version name
   * @param {Array} projectKey - The project key
   * @return {Promise<String>} Resolves to version name string, as it exists in JIRA
   */


  createProjectVersion(versionName, projectKey) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      let searchName = versionName.toLowerCase();
      const versions = yield _this3.jira.getVersions(projectKey);
      const exists = versions.find(v => v.name.toLowerCase() == searchName);

      if (exists) {
        return exists;
      }

      const result = yield _this3.jira.createVersion({
        name: versionName,
        project: projectKey
      });
      return result;
    })();
  }
  /**
   * Retreive the jira issue by ID.
   * Also attempt to match a slack user to the reporter's email address.
   *
   * @param {String} ticketId - The ticket ID of the issue to retrieve.
   * @return {Promise} Resolves a jira issue object, with added `slackUser` property.
   */


  getJiraIssue(ticketId) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      if (!_this4.jira) {
        return Promise.reject('Jira is not configured.');
      }

      return _this4.jira.findIssue(ticketId).then(origTicket => {
        const ticket = Object.assign({}, origTicket);
        return _this4.slack.findUser(ticket.fields.reporter.emailAddress, ticket.fields.reporter.displayName).then(slackUser => {
          ticket.slackUser = slackUser;
          return ticket;
        }).catch(() => ticket);
      });
    })();
  }
  /**
   * Should ticket be included in changelog
   * @param   {Object} ticket - Jira ticket object
   * @returns {Boolean}
   */


  includeTicket(ticket) {
    const type = ticket.fields.issuetype.name;

    if (Array.isArray(this.config.jira.includeIssueTypes) && this.config.jira.includeIssueTypes.length) {
      return this.config.jira.includeIssueTypes.includes(type);
    } else if (Array.isArray(this.config.jira.excludeIssueTypes)) {
      return !this.config.jira.excludeIssueTypes.includes(type);
    }
  }
  /**
   * Gets all tickets associated with a commit
   * @param   {Object} log - A commit's log object
   * @returns {Array} List of tickets in commit
   */


  getTickets(log) {
    const configPattern = this.config.jira.ticketIDPattern;
    const searchPattern = new RegExp(configPattern.source, `${configPattern.flags || ''}g`);
    return log.fullText.match(searchPattern) || [];
  }

}

exports.default = Jira;
//# sourceMappingURL=Jira.js.map