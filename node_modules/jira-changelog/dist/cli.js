#!/usr/bin/env node

/**
 * The jira-changelog CLI
 */
"use strict";

require("@babel/polyfill");

require("source-map-support/register");

var _commander = _interopRequireDefault(require("commander"));

var _lodash = _interopRequireDefault(require("lodash"));

var _ejs = _interopRequireDefault(require("ejs"));

var _path = _interopRequireDefault(require("path"));

var _Slack = _interopRequireDefault(require("./Slack"));

var _htmlEntities = _interopRequireDefault(require("html-entities"));

var _Config = require("./Config");

var _SourceControl = _interopRequireDefault(require("./SourceControl"));

var _Jira = _interopRequireDefault(require("./Jira"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

runProgram();
/**
 * Parse command line arguments
 */

function commandLineArgs() {
  const pkg = require('../package.json');

  _commander.default.version(pkg.version).option('-c, --config <filepath>', 'Path to the config file.').option('-r, --range <from>...<to>', 'git commit range for changelog', parseRange).option('-d, --date <date>[...date]', 'Only include commits after this date', parseRange).option('-s, --slack', 'Automatically post changelog to slack (if configured)').option('--release [release]', 'Assign a release version to these stories').parse(process.argv);
}
/**
 * Run the main program
 */


function runProgram() {
  return _runProgram.apply(this, arguments);
}
/**
 * Post the changelog to slack
 *
 * @param {Object} config - The configuration object
 * @param {Object} data - The changelog data object.
 * @param {String} changelogMessage - The changelog message
 */


function _runProgram() {
  _runProgram = _asyncToGenerator(function* () {
    try {
      commandLineArgs(); // Determine the git workspace path

      let gitPath = process.cwd();

      if (_commander.default.args.length) {
        gitPath = _commander.default.args[0];
      }

      gitPath = _path.default.resolve(gitPath); // Config file path

      var configPath;

      if (_commander.default.config) {
        configPath = _path.default.resolve(_commander.default.config);
      } else {
        configPath = _path.default.join(gitPath, _Config.CONF_FILENAME);
      }

      const config = (0, _Config.readConfigFile)(configPath);
      const jira = new _Jira.default(config);
      const source = new _SourceControl.default(config); // Release flag used, but no name passed

      if (_commander.default.release === true) {
        if (typeof config.jira.generateReleaseVersionName !== 'function') {
          console.log("You need to define the jira.generateReleaseVersionName function in your config, if you're not going to pass the release version name in the command.");
          return;
        }

        _commander.default.release = yield config.jira.generateReleaseVersionName();
      } // Get logs


      const range = getRangeObject(config);
      const commitLogs = yield source.getCommitLogs(gitPath, range);
      const changelog = yield jira.generate(commitLogs, _commander.default.release); // Template data template

      let data = yield transformCommitLogs(config, changelog);

      if (typeof config.transformData == 'function') {
        data = yield Promise.resolve(config.transformData(data));
      }

      data.jira = {
        baseUrl: config.jira.baseUrl,
        releaseVersions: jira.releaseVersions
      }; // Render and output template

      const entitles = new _htmlEntities.default.AllHtmlEntities();

      const changelogMessage = _ejs.default.render(config.template, data);

      console.log(entitles.decode(changelogMessage)); // Post to slack

      if (_commander.default.slack) {
        postToSlack(config, data, changelogMessage);
      }
    } catch (e) {
      console.error('Error: ', e.stack);
      console.log(e.message);
    }
  });
  return _runProgram.apply(this, arguments);
}

function postToSlack(_x, _x2, _x3) {
  return _postToSlack.apply(this, arguments);
}
/**
 * Convert a range string formatted as "a...b" into an array.
 *
 * @param {String} rangeStr - The range string.
 * @return {Array}
 */


function _postToSlack() {
  _postToSlack = _asyncToGenerator(function* (config, data, changelogMessage) {
    const slack = new _Slack.default(config);

    if (!slack.isEnabled() || !config.slack.channel) {
      console.error('Error: Slack is not configured.');
      return;
    }

    console.log(`\nPosting changelog message to slack channel: ${config.slack.channel}...`);

    try {
      // Transform for slack
      if (typeof config.transformForSlack == 'function') {
        changelogMessage = yield Promise.resolve(config.transformForSlack(changelogMessage, data));
      } // Post to slack


      yield slack.postMessage(changelogMessage, config.slack.channel);
      console.log('Done');
    } catch (e) {
      console.log('Error: ', e.stack);
    }
  });
  return _postToSlack.apply(this, arguments);
}

function parseRange(rangeStr) {
  return rangeStr.split(/\.{3,3}/);
}
/**
 * Filter commit logs into template data.
 *
 * Data:
 * -----
 *  {
 *    commits: {
 *      all: [],       // all commits
 *      tickets: [],   // commits associated with jira tickets
 *      noTickets: []  // commits not associated with jira tickets
 *    },
 *    tickets: {
 *      all: [],       // all tickets
 *      approved: [],  // tickets marked as approved
 *      pending: [],   // tickets not marked as approved
 *      pendingByOwner: [] // pending tickets arranged under ticket reporters.
 *    }
 *  }
 *
 * @param {Object} config - The config object provided by Config.getConfigForPath
 * @param {Array} logs - List of commit logs and their jira tickets.
 *
 * @return {Promise} Resolves to an object with filtered commit/ticket data
 */


function transformCommitLogs(config, logs) {
  let approvalStatus = config.jira.approvalStatus;

  if (!Array.isArray(approvalStatus)) {
    approvalStatus = [approvalStatus];
  } // Tickets and their commits


  const ticketHash = logs.reduce((all, log) => {
    log.tickets.forEach(ticket => {
      all[ticket.key] = all[ticket.key] || ticket;
      all[ticket.key].commits = all[ticket.key].commits || [];
      all[ticket.key].commits.push(log);
    });
    return all;
  }, {});

  let ticektList = _lodash.default.sortBy(Object.values(ticketHash), ticket => ticket.fields.issuetype.name);

  let pendingTickets = ticektList.filter(ticket => !approvalStatus.includes(ticket.fields.status.name)); // Pending ticket owners and their tickets/commits

  const reporters = {};
  pendingTickets.forEach(ticket => {
    const email = ticket.fields.reporter.emailAddress;

    if (!reporters[email]) {
      reporters[email] = {
        email,
        name: ticket.fields.reporter.displayName,
        slackUser: ticket.slackUser,
        tickets: [ticket]
      };
    } else {
      reporters[email].tickets.push(ticket);
    }
  });

  const pendingByOwner = _lodash.default.sortBy(Object.values(reporters), item => item.user); // Output filtered data


  return {
    commits: {
      all: logs,
      tickets: logs.filter(commit => commit.tickets.length),
      noTickets: logs.filter(commit => !commit.tickets.length)
    },
    tickets: {
      pendingByOwner,
      all: ticektList,
      approved: ticektList.filter(ticket => approvalStatus.includes(ticket.fields.status.name)),
      pending: pendingTickets
    }
  };
}
/**
 * Construct the range object from the CLI arguments and config
 *
 * @param {Object} config - The config object provided by Config.getConfigForPath
 * @return {Object}
 */


function getRangeObject(config) {
  const range = {};
  const defaultRange = config.sourceControl && config.sourceControl.defaultRange ? config.sourceControl.defaultRange : {};

  if (_commander.default.range && _commander.default.range.length) {
    range.from = _commander.default.range[0];
    range.to = _commander.default.range[1];
  }

  if (_commander.default.dateRange && _commander.default.dateRange.length) {
    range.after = _commander.default.dateRange[0];

    if (_commander.default.dateRange.length > 1) {
      range.before = _commander.default.dateRange[1];
    }
  } // Use default range


  if (!Object.keys(range).length && Object.keys(defaultRange).length) {
    Object.assign(range, defaultRange);
  }

  if (!Object.keys(range).length) {
    throw new Error('No range defined for the changelog.');
  }

  return range;
}
//# sourceMappingURL=cli.js.map